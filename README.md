_This project has been created as part of the 42 curriculum by ldecavel_

### DESCRIPTION

The goal of this project is to develop a multi-agent pathfinding algorithm on a weighted graph. The program computes collision-free paths for multiple agents, and then displays the simulation using a modern external graphics library.

### INSTRUCTIONS

To **_install_** the project virtual environment :

```bash
make install
```

To **_run_** the program :

```bash
make run [ARGS="map_path window_size"]
```
> [!NOTE]  
> Command-line arguments are optional. By default, the program loads maps/easy/01_linear_path.txt and uses window_size=3. window_size is a screen divider: 1 opens a full-screen window, 3 opens a window that is one third of your screen.

To **_clean_** the files generated by the installation :

```bash
make clean
```

To check flake8 and mypy **_norms_** :

```bash
make lint
```

To check flake8 and mypy **_norms_** with **_strict_** flags :

```bash
make lint-strict
```

To run the program with the **_python debugger_** :

```bash
make debug
```

### ALGORITHMS

The pathfinding used in this project is a simple BFS variant inspired by Dijkstra, but it is not a true Dijkstra implementation.

- Nodes are not handled with a full weight system.
- Priority zones bias the search (they are preferred over others).
- Restricted zones are treated as a cost of 2 turns by expanding them as two normal steps instead of using real weighted edges.

#### Multi-agent handling (reservation table)
The program computes a path for each drone while keeping a time-based reservation of the graph:

- For each planned path, every hub and connection is reserved for every turn where the drone occupies it.
- When planning the next drone, the algorithm checks these reservations to avoid collisions and conflicts in time.
- Each object (Hub or Connection) has its own reservation table

#### Waiting / delayed start
If a drone cannot move at turn `t` (because the next hub/connection is already reserved), it does not force its way through. Instead, it waits at the start hub and retries later using a decayed start.

### MAP FORMAT

Map files are plain text.

#### RULES
- Lines starting with `#` are comments.
- The first required line is: `nb_drones: <positive_int>`
- Then define zones:
  - `start_hub: <name> <x> <y> [metadata]`
  - `end_hub: <name> <x> <y> [metadata]`
  - `hub: <name> <x> <y> [metadata]`
- Then define connections (bidirectional edges):
  - `connection: <zone1>-<zone2> [metadata]`
- Zone names must be unique and must not contain spaces or dashes.
- Coordinates are positive integers.
- There is exactly one start and one end.

#### METADATA (optional)
- Metadata is inside `[...]`, space-separated, order does not matter.
- Zone metadata:
  - `zone=normal|restricted|blocked|priority` (default: `normal`)
  - `color=<word>` (default: none)
  - `max_drones=<positive_int>` (default: `1`)
- Connection metadata:
  - `max_link_capacity=<positive_int>` (default: `1`)

#### ZONE TYPES
- `normal`: cost 1 turn (default)
- `restricted`: cost 2 turns
- `priority`: cost 1 turn (but should be preferred by the algorithm)
- `blocked`: forbidden (cannot be entered)

#### EXAMPLE
```txt
# Simple linear path
nb_drones: 2

start_hub: start 0 0 [color=green]
hub: waypoint1 1 0 [zone=normal color=blue]
hub: waypoint2 2 0 [zone=normal color=blue]
end_hub: goal 3 0 [color=red]

connection: start-waypoint1
connection: waypoint1-waypoint2
connection: waypoint2-goal
```

### VISUALIZATION
Made with **arcade**.

#### KEYMAPS
- Mouse wheel: zoom
- Click + drag: move the camera
- Arrows or H/L (vim-like): move across turns
- Spacebar: autorun (play/pause)
- R: rewind

#### HUD
- Turn counter
- Program title

#### SHAPES
- SQUARE: restricted
- CIRCLE: normal
- OCTAGON: blocked
- TRIANGLE: priority

#### COLORS
- Arcade supported colors

### RESOURCES

The links below helped me understand multi-agent algorithms and provided inspiration before I started. AI helped with debugging and was used as a reference for function prototypes and library usage in the graphics library.

[Pathfinding](https://qiao.github.io/PathFinding.js/visual/)  
[Youtube: Dinic's Algorithm](https://youtu.be/M6cm8UeeziI?si=AsJ-KL55jxtpDdqS)  
[Youtube: Path-finding Visualization Comparison](https://youtu.be/aW9kZcJx64o?si=Q14Je40rAbvA48by)  
[Youtube: A* (A Star) Search](https://www.youtube.com/watch?v=71CEj4gKDnE&pp=ugMICgJmchABGAHKBQNiZnM%3D)  
[Youtube: A* vs Dijkstra](https://youtu.be/9REexHx0hDY?si=SPLF461INFOGHA2Y)  
[Youtube: Understanding A*](https://youtu.be/i0x5fj4PqP4?si=dcigyuRwOUBExD2U)  
[Wikipedia: Dinic's algorithm](https://en.wikipedia.org/wiki/Dinic%27s_algorithm)  
[Wikipedia: Dijkstra's algorithn](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)  
[Wikipedia: Multi-agent pathfinding](https://en.wikipedia.org/wiki/Multi-agent_pathfinding)  
[Chatgpt](https://chatgpt.com)  
